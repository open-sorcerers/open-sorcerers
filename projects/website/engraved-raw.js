'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var ramda = require('ramda');
var fluture = require('fluture');
var camelCase = require('camel-case');
var helloColor = _interopDefault(require('hello-color'));
var palx = _interopDefault(require('palx'));
var colorable = _interopDefault(require('colorable'));

var memo = ramda.memoizeWith(ramda.identity);
var j2 = function (x) { return JSON.stringify(x, null, 2); };

var C = {
  n: "\n"
};

var REGEX_HEX3 = /[a-f0-9]{3}/;
var REGEX_HEX6 = /[a-f0-9]{6}/;

var testHex = memo(
  function (z) { return z &&
    (z.length === 3 || z.length === 6) &&
    (REGEX_HEX3.test(z) || REGEX_HEX6.test(z)); }
);
var noHexLead = memo(function (h) { return h && h[0] !== "#"; });
var noParens = memo(function (h) { return h && h.includes && !h.includes("("); });

var convert = memo(function (x) { return noHexLead(x) ? (noParens(x) ? x : "") : x.slice(1); }
);

var name = "engraved";
var version = "0.0.3";
var description = "generate static color palettes at build time";
var main = "engraved.js";
var module$1 = "engraved.mjs";
var bin = {
	engraved: "engraved-cli.js"
};
var repository = "//github.com/open-sorcerers/open-sorcerers";
var author = "brekk";
var license = "MIT";
var dependencies = {
	"camel-case": "^4.1.1",
	"color-contrast-checker": "^1.5.0",
	colorable: "^1.0.5",
	"eslint-config-sorcerers": "^0.0.2",
	fluture: "^12.1.1",
	"get-stdin": "^7.0.0",
	"hello-color": "^1.0.2",
	palx: "^1.0.3",
	polished: "^3.4.4",
	ramda: "^0.26.1",
	torpor: "^0.0.4",
	"yargs-parser": "^16.1.0"
};
var devDependencies = {
	chance: "^1.1.4",
	eslint: "^6.8.0",
	prettier: "^1.19.1",
	"prettier-eslint": "^9.0.1",
	rollup: "^1.31.0",
	torpor: "^0.0.3"
};
var jest = {
	testPathIgnorePatterns: [
		"<rootDir>/engraved.js"
	]
};
var PKG = {
	name: name,
	version: version,
	description: description,
	main: main,
	module: module$1,
	bin: bin,
	repository: repository,
	author: author,
	license: license,
	"private": false,
	dependencies: dependencies,
	devDependencies: devDependencies,
	jest: jest
};

var constantColor = memo(function (z) {
  var v = testHex(z) ? ("'#" + z + "'") : ("'" + z + "'");
  return ("const $" + z + " = " + v)
});

var namedColors = ramda.pipe(ramda.filter(ramda.identity), ramda.uniq, ramda.map(constantColor), ramda.join(C.n));

var renderJS = ramda.curry(function (engraver, ref, futureValue) {
    var flatten = ref.flatten;

    return ramda.pipe(
    ramda.map(
      function (ref) {
          var known = ref.known;
          var routes = ref.routes;
          var initial = ref.initial;

          return "/* autogenerated by engraved v" + (PKG.version) + " */\n\n" +
        namedColors(known) +
        "\n\nexport default Object.freeze(" +
        engraver({ flatten: flatten }, initial, routes) +
        ")";
    }
    )
  )(futureValue);
}
);

var unstringJS = memo(function (zzz) {
  var lookup = zzz.indexOf('"$');
  if (lookup === -1) { return zzz }
  var yyy = zzz.substr(0, lookup) + zzz.substr(lookup + 1);
  return yyy.replace(/"/g, "")
});

var engrave = ramda.curry(function (ref, initial, routes) {
    var flatten = ref.flatten;

    return ramda.pipe(
    ramda.reduce(
      function (prev, ref) {
          var route = ref[0];
          var val = ref[1];

          return flatten
          ? ramda.assoc(camelCase.camelCase(route.join("-")), val, prev)
          : ramda.assocPath(route, val, prev);
    },
      flatten ? {} : initial
    ),
    j2,
    ramda.split(C.n),
    ramda.map(unstringJS),
    ramda.join(C.n)
  )(routes);
}
);

var pair = ramda.curry(
  ramda.memoizeWith(ramda.identity, function (ff, bb) { return colorable({ foreground: ff, background: bb }); })
);

var over = ramda.curry(function (de, nu) { return nu / de; });

var getAccessibility = ramda.pipe(
  ramda.path([0, "combinations", 0, "accessibility"]),
  ramda.toPairs,
  ramda.filter(ramda.nth(1)),
  ramda.length,
  over(4)
);

var compare = ramda.curry(function (ff, bb) {
  var compared = pair(ff, bb);
  var readability = getAccessibility(compared);
  var raw = { foreground: ff, background: bb };
  var options = ramda.map(palx, raw);
  var best = ramda.map(helloColor, raw);
  var suggested =
    readability < 1 / 2
      ? best.foreground.dark
        ? {
            foreground: best.foreground.base,
            background: best.foreground.color
          }
        : {
            foreground: best.foreground.color,
            background: best.foreground.base
          }
      : raw;

  return { best: best, options: options, compared: compared, readability: readability, suggested: suggested }
});

var custom = ramda.curry(function (config, xx) {
  var isCancelled = false;
  var cancel = function () {
    isCancelled = true;
  };
  var consumption = function (initialThing) { return new fluture.Future(function (bad, good) {
      var known = [];
      var routes = [];
      var consume = function (thing, pathing) { return ramda.pipe(
          ramda.toPairs,
          ramda.map(function (ref) {
            var w = ref[0];
            var x = ref[1];

            /* istanbul ignore next */
            if (isCancelled) { return }
            var y = convert(x);
            var toHere = pathing.concat(w);
            if (ramda.is(String, x)) {
              if (y !== "" && w !== "name") {
                known.push(y);
                routes.push([toHere, "$" + y]);
              }
            } else {
              consume(x, toHere);
            }
          })
        )(thing); };
      try {
        ramda.pipe(
          function () { return consume(initialThing, []); },
          function () {
            setTimeout(function () { return good({ initial: initialThing, known: known, routes: routes }); }, 1);
          }
        )();
        return cancel
      } catch (e) {
        bad(e);
        return cancel
      }
    }); };

  return new fluture.Future(function (bad, good) {
    try {
      if (!xx || typeof xx !== "object") {
        bad(new Error("engraved - expected to be given an object as an input"));
      } else {
        ramda.pipe(consumption, renderJS(engrave, config), function (yy) { return fluture.fork(bad)(good)(yy); })(
          xx
        );
      }
      return cancel
    } catch (e) {
      /* istanbul ignore next */
      bad(e);
      /* istanbul ignore next */
      return cancel
    }
  })
});
var engraved = custom({ flatten: true });

exports.compare = compare;
exports.custom = custom;
exports.engraved = engraved;
